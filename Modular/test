sequenceDiagram
    title Full Message Flow with Hash-Based Routing and Multiple Consumers

    participant App as ðŸ“¤ Producer (App/Service)
    participant Hasher as ðŸ” Hash Function
    participant SB as ðŸ“¬ Azure Service Bus (1000 Bucketed Sessions)
    participant PodA as ðŸ§  Consumer Pod A
    participant PodB as ðŸ§  Consumer Pod B
    participant Redis as ðŸ’¾ Redis Cache
    participant MemA as ðŸ§  In-Memory Cache (Pod A)
    participant MemB as ðŸ§  In-Memory Cache (Pod B)

    App->>Hasher: Hash(securityId) â†’ bucket-N
    Hasher-->>App: sessionId = "bucket-0423"
    App->>SB: Send(message, sessionId)

    Note over SB: Messages grouped under sessionId buckets

    SB->>PodA: Assign session "bucket-0423"
    PodA->>MemA: Check if security state is loaded
    alt Not in memory
        PodA->>Redis: GET transactions:{securityId}
        Redis-->>PodA: Return list or null
        PodA->>MemA: Store state locally
    else Already in memory
        Note right of PodA: Use existing in-memory state
    end
    PodA->>MemA: Process message & update state
    alt State updated
        PodA->>Redis: Conditional SET (Lua + version check)
    end

    SB->>PodB: Assign session "bucket-0079"
    PodB->>MemB: Check if security state is loaded
    alt Not in memory
        PodB->>Redis: GET transactions:{securityId}
        Redis-->>PodB: Return list or null
        PodB->>MemB: Store state locally
    else Already in memory
        Note right of PodB: Use existing in-memory state
    end
    PodB->>MemB: Process message & update state
    alt State updated
        PodB->>Redis: Conditional SET (Lua + version check)
    end

    Note over PodA,PodB: All consumers share same routing logic, work in parallel


