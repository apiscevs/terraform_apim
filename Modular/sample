1  Ambient request buffer
csharp
Копировать
Редактировать
// AmbientRequestCache.cs
using System.Collections.Generic;
using System.Threading;

namespace YourApp.Caching;

/// <summary>
/// Holds a per‑async‑flow (per HTTP request / message) dictionary.
/// </summary>
public static class AmbientRequestCache
{
    private static readonly AsyncLocal<Dictionary<string, object>> _state = new();

    private static Dictionary<string, object> State
        => _state.Value ??= new Dictionary<string, object>();

    public static bool TryGet<T>(string key, out T value)
    {
        if (State.TryGetValue(key, out var o) && o is T t)
        {
            value = t;
            return true;
        }
        value = default!;
        return false;
    }

    public static void Set<T>(string key, T value) => State[key] = value!;

    public static void Clear() => State.Clear();
}
2  Singleton wrapper that uses the ambient buffer
csharp
Копировать
Редактировать
// PerRequestEasyCachingProvider.cs
using System;
using System.Threading;
using System.Threading.Tasks;
using EasyCaching.Core;

namespace YourApp.Caching;

/// <summary>
/// Singleton decorator: ensures one Redis round‑trip per key per request
/// by using an AsyncLocal dictionary.
/// </summary>
public sealed class PerRequestEasyCachingProvider : DelegatingEasyCachingProvider
{
    public PerRequestEasyCachingProvider(IEasyCachingProvider inner)
        : base(inner) { }

    /* ------------ intercept hot paths ------------ */

    public override async Task<CacheValue<T>> GetAsync<T>(
        string key,
        CancellationToken token = default)
    {
        if (AmbientRequestCache.TryGet<T>(key, out var local))
            return new CacheValue<T>(local, true);

        var remote = await base.GetAsync<T>(key, token);
        if (remote.HasValue)
            AmbientRequestCache.Set(key, remote.Value!);

        return remote;
    }

    public override async Task<CacheValue<T>> GetAsync<T>(
        string            key,
        Func<Task<T>>     factory,
        TimeSpan?         expiration   = null,
        CancellationToken token        = default)
    {
        if (AmbientRequestCache.TryGet<T>(key, out var local))
            return new CacheValue<T>(local, true);

        var remote = await base.GetAsync(key, factory, expiration, token);
        if (remote.HasValue)
            AmbientRequestCache.Set(key, remote.Value!);

        return remote;
    }

    public override Task SetAsync<T>(
        string            key,
        T                 value,
        TimeSpan?         expiration   = null,
        CancellationToken token        = default)
    {
        AmbientRequestCache.Set(key, value);
        return base.SetAsync(key, value, expiration, token);
    }
}
DelegatingEasyCachingProvider is the small pass‑through base from the previous
message (no changes).

3  Clear the ambient cache at the start / end of every request
csharp
Копировать
Редактировать
// in Program.cs or Startup.cs – BEFORE UseEndpoints / MapControllers
app.Use(async (ctx, next) =>
{
    AmbientRequestCache.Clear();   // fresh dictionary
    await next();
    AmbientRequestCache.Clear();   // don’t leak between requests
});
For a queue/Bus handler, wrap the invocation similarly.

4  DI registration (all providers remain singleton → factory happy)
csharp
Копировать
Редактировать
services.AddEasyCaching(opts =>
{
    opts.WithJson();
    opts.UseInMemory("MemCache");

    opts.UseRedis(r =>
    {
        r.DBConfig.Endpoints.Add(new ServerEndPoint(cfg.Host, cfg.Port.Value));
        r.DBConfig.Password = cfg.Password;
        r.DBConfig.IsSsl    = cfg.IsSsl;
        r.SerializerName    = "json";
    }, "redis");
});

/* Replace *default* provider with our singleton decorator */
services.AddSingleton<IEasyCachingProvider>(sp =>
{
    var factory = sp.GetRequiredService<IEasyCachingProviderFactory>();
    var redis   = factory.GetCachingProvider("redis");          // raw singleton
    return new PerRequestEasyCachingProvider(redis);            // decorated singleton
});