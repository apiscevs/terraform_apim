// how many docs to insert per container
const int DocsToInsert = 5000;
// degree of parallelism
const int MaxConcurrency = 50;

// a helper to flood a single container
async Task FloodContainerAsync(Container container)
{
    long totalChargeScaled = 0;
    var sw = Stopwatch.StartNew();
    var throttler = new SemaphoreSlim(MaxConcurrency);

    var tasks = Enumerable.Range(0, DocsToInsert)
        .Select(async i =>
        {
            await throttler.WaitAsync();
            try
            {
                var doc = new
                {
                    id      = Guid.NewGuid().ToString(),
                    created = DateTime.UtcNow,
                    blob    = new string('x', 1024)  // ~1KB payload
                };
                var resp = await container.CreateItemAsync(doc, new PartitionKey(doc.id));
                Interlocked.Add(ref totalChargeScaled, (long)(resp.RequestCharge * 1000));
            }
            catch (CosmosException ex) when (ex.StatusCode == HttpStatusCode.TooManyRequests)
            {
                await Task.Delay(ex.RetryAfter);
            }
            finally
            {
                throttler.Release();
            }
        })
        .ToList();

    await Task.WhenAll(tasks);
    sw.Stop();

    double totalCharge = totalChargeScaled / 1000.0;
    Console.WriteLine(
        $"ðŸ“ˆ {container.Id}: inserted {DocsToInsert} docs in {sw.Elapsed.TotalSeconds:F1}s, " +
        $"total RU={totalCharge:F1}, avg RU/doc={totalCharge/DocsToInsert:F3}"
    );
}

// call it for each container you just scaled
foreach (var def in containers)
{
    var container = database.GetContainer(def.Name);
    Console.WriteLine($"\n--- Flooding '{def.Name}' with test docs ---");
    await FloodContainerAsync(container);
}