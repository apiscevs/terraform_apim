using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;

public sealed class MessageProcessor
{
    private readonly ILogger<MessageProcessor> _log;
    private readonly IReadOnlyDictionary<string, IMessageHandler> _handlers;

    private readonly ConcurrentDictionary<string, int> _counts = new();
    private const int Threshold = 100;

    public MessageProcessor(ILogger<MessageProcessor> log,
                            IReadOnlyDictionary<string, IMessageHandler> handlers)
    {
        _log = log;
        _handlers = handlers;
    }

    public async Task OnMessageAsync(ServiceBusReceivedMessage msg, CancellationToken ct)
    {
        var type = msg.Subject ?? msg.ContentType ?? "unknown";

        if (_handlers.TryGetValue(type, out var handler))
        {
            await handler.HandleAsync(msg, ct);
            return;
        }

        IncrementAndMaybeLog(type, msg.MessageId);
    }

    private void IncrementAndMaybeLog(string type, string? messageId)
    {
        // Atomic per-key increment
        int after = _counts.AddOrUpdate(type, 1, static (_, c) => c + 1);

        if (after < Threshold) return;

        // Single logger: try to reset from the currently observed value to 0.
        // Only one thread will succeed; others will see a changed value and skip.
        while (true)
        {
            if (!_counts.TryGetValue(type, out int observed)) return;     // very unlikely
            if (observed < Threshold) return;                             // someone else already reset+logged

            if (_counts.TryUpdate(type, 0, observed))
            {
                _log.LogWarning(
                    "Received '{MessageType}' without a processor {Count} times (last MessageId={MessageId}). Counter reset.",
                    type, observed, messageId);
                return;
            }
            // else: value changed; loop and re-check
        }
    }
}
