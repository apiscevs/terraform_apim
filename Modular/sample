1  Request‑scoped dictionary (lives exactly one DI scope)
csharp
Копировать
Редактировать
// RequestCache.cs
using System.Collections.Generic;

namespace YourApp.Caching;

/// <summary>
/// First‑level cache that survives only for the lifetime of the current
/// dependency‑injection *scope* (e.g. one HTTP request or message).
/// </summary>
public sealed class RequestCache
{
    private readonly Dictionary<string, object> _data = new();

    public bool TryGet<T>(string key, out T value)
    {
        if (_data.TryGetValue(key, out var obj) && obj is T t)
        {
            value = t;
            return true;
        }
        value = default!;
        return false;
    }

    public void Set<T>(string key, T value) => _data[key] = value!;
}
2  Wrapper that checks the scoped cache first, then Redis
csharp
Копировать
Редактировать
// ScopedEasyCachingProvider.cs
using System;
using System.Threading;
using System.Threading.Tasks;
using EasyCaching.Core;
using EasyCaching.Core.Internal;   // ⚠️ brings in CachingProviderWrapperBase

namespace YourApp.Caching;

/// <summary>
/// Decorator: intercepts Get*/Set* calls so Redis is hit at most *once* per key
/// per request.  Everything else is forwarded by the base class.
/// </summary>
public sealed class ScopedEasyCachingProvider : CachingProviderWrapperBase
{
    private readonly RequestCache _request;

    public ScopedEasyCachingProvider(
        IEasyCachingProvider inner,      // real Redis provider
        RequestCache         requestCache)
        : base(inner)                    // base class wires all pass‑throughs
    {
        _request = requestCache;
    }

    /* -------------------- overrides -------------------- */

    public override async Task<CacheValue<T>> GetAsync<T>(
        string key,
        CancellationToken token = default)
    {
        // 1️⃣  look in the per‑request dictionary
        if (_request.TryGet<T>(key, out var local))
            return new CacheValue<T>(local, true);

        // 2️⃣  miss → delegate to Redis
        var remote = await base.GetAsync<T>(key, token);

        // 3️⃣  populate request cache so the next call is in‑memory
        if (remote.HasValue)
            _request.Set(key, remote.Value!);

        return remote;
    }

    public override async Task<CacheValue<T>> GetAsync<T>(
        string            key,
        Func<Task<T>>     factory,
        TimeSpan?         expiration   = null,
        CancellationToken token        = default)
    {
        if (_request.TryGet<T>(key, out var local))
            return new CacheValue<T>(local, true);

        var remote = await base.GetAsync(key, factory, expiration, token);
        if (remote.HasValue)
            _request.Set(key, remote.Value!);

        return remote;
    }

    public override Task SetAsync<T>(
        string            key,
        T                 value,
        TimeSpan?         expiration   = null,
        CancellationToken token        = default)
    {
        _request.Set(key, value);            // keep request‑scope in sync
        return base.SetAsync(key, value, expiration, token);
    }
}
CachingProviderWrapperBase already implements every other interface member by
forwarding it to the inner provider, so we only override what we care about.

3  Single extension to wire everything up
csharp
Копировать
Редактировать
// CachingSetup.cs
using EasyCaching.Core;
using EasyCaching.InMemory;
using EasyCaching.Redis;
using Microsoft.Extensions.DependencyInjection;
using Serilog;

public static class CachingSetup
{
    /// <summary>
    /// Registers EasyCaching (Redis + in‑proc) **and** the request‑scoped decorator
    /// that prevents redundant Redis calls in the same request.
    /// </summary>
    public static void ConfigureCaching(
        this IServiceCollection services,
        RedisConfiguration?     cacheCfg,
        ILogger                 logger)
    {
        cacheCfg ??= new RedisConfiguration();
        services.AddSingleton(cacheCfg);

        /* 1️⃣  request‑scoped dictionary */
        services.AddScoped<RequestCache>();

        /* 2️⃣  normal EasyCaching registration */
        services.AddEasyCaching(opts =>
        {
            logger.Information("Configuring EasyCaching …");

            opts.WithJson();                 // System.Text.Json (faster)
            opts.UseInMemory("MemCache");    // fallback in‑proc cache

            if (!string.IsNullOrWhiteSpace(cacheCfg.Host) && cacheCfg.Port is not null)
            {
                opts.UseRedis(redis =>
                {
                    redis.DBConfig.Endpoints.Add(
                        new ServerEndPoint(cacheCfg.Host, cacheCfg.Port.Value));

                    if (!string.IsNullOrWhiteSpace(cacheCfg.Password))
                        redis.DBConfig.Password = cacheCfg.Password;

                    redis.DBConfig.IsSsl   = cacheCfg.IsSsl;
                    redis.SerializerName   = "json";
                }, "redis");                 // ← give this provider the name \"redis\"
            }
            else
            {
                logger.Information(\"Redis host empty – using in‑memory provider only\");
            }
        });

        /* 3️⃣  when anything asks for IEasyCachingProvider, give them the wrapper   */
        services.AddScoped<IEasyCachingProvider>(sp =>
        {
            var factory  = sp.GetRequiredService<IEasyCachingProviderFactory>();
            var redis    = factory.GetCachingProvider(\"redis\");   // original provider
            var reqCache = sp.GetRequiredService<RequestCache>();  // per‑request dict
            return new ScopedEasyCachingProvider(redis, reqCache); // wrapped version
        });
    }
}
