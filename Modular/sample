using System;
using System.Linq;
using System.Linq.Expressions;

namespace YourApp.Filters
{
    public enum DateRange
    {
        None = 0,
        Today,
        Yesterday,
        LastSevenDays,
        LastThirtyDays
    }

    /// <summary>
    /// Computes [start, end) windows using a custom UTC rollover time.
    /// </summary>
    public static class BusinessDayWindows
    {
        /// <summary>
        /// Returns the [start, end) window for the given DateRange.
        /// All values are UTC; weekends included.
        /// </summary>
        public static (DateTime startUtc, DateTime endUtc) GetWindow(DateRange range, TimeOnly rollOverUtc)
        {
            if (range == DateRange.None)
                return (DateTime.MinValue, DateTime.MaxValue);

            var now = DateTime.UtcNow;
            var todayRoll = now.Date.Add(rollOverUtc.ToTimeSpan());

            var startCurrent = now >= todayRoll ? todayRoll : todayRoll.AddDays(-1);
            var startNext    = startCurrent.AddDays(1);

            return range switch
            {
                DateRange.Today          => (startCurrent,               startNext),
                DateRange.Yesterday      => (startCurrent.AddDays(-1),   startCurrent),
                DateRange.LastSevenDays  => (startCurrent.AddDays(-7),   startNext),
                DateRange.LastThirtyDays => (startCurrent.AddDays(-30),  startNext),
                _                        => (DateTime.MinValue, DateTime.MaxValue)
            };
        }
    }

    /// <summary>
    /// Composable, EF-translatable predicate builders for [start, end).
    /// Works with any model and any DateTime/DateTimeOffset property selector.
    /// </summary>
    public static class DateRangePredicates
    {
        // -------- DateTime (UTC) ----------
        public static Expression<Func<T, bool>> BetweenUtc<T>(
            Expression<Func<T, DateTime>> utcSelector,
            DateTime startUtc,
            DateTime endUtc)
        {
            var param = Expression.Parameter(typeof(T), "x");
            var body  = ReplaceParameter(utcSelector, param); // x => utcSelector(x)

            var ge = Expression.GreaterThanOrEqual(body, Expression.Constant(startUtc, typeof(DateTime)));
            var lt = Expression.LessThan(body,           Expression.Constant(endUtc,   typeof(DateTime)));
            var and = Expression.AndAlso(ge, lt);

            return Expression.Lambda<Func<T, bool>>(and, param);
        }

        public static IQueryable<T> ApplyDateRangeUtc<T>(
            this IQueryable<T> query,
            Expression<Func<T, DateTime>> utcSelector,
            DateRange range,
            TimeOnly rollOverUtc)
        {
            if (range == DateRange.None) return query;

            var (start, end) = BusinessDayWindows.GetWindow(range, rollOverUtc);
            return query.Where(BetweenUtc(utcSelector, start, end));
        }

        // -------- DateTimeOffset (UTC) ----------
        public static Expression<Func<T, bool>> BetweenOffsetUtc<T>(
            Expression<Func<T, DateTimeOffset>> utcOffsetSelector,
            DateTimeOffset startUtc,
            DateTimeOffset endUtc)
        {
            var param = Expression.Parameter(typeof(T), "x");
            var body  = ReplaceParameter(utcOffsetSelector, param);

            var ge = Expression.GreaterThanOrEqual(body, Expression.Constant(startUtc, typeof(DateTimeOffset)));
            var lt = Expression.LessThan(body,           Expression.Constant(endUtc,   typeof(DateTimeOffset)));
            var and = Expression.AndAlso(ge, lt);

            return Expression.Lambda<Func<T, bool>>(and, param);
        }

        public static IQueryable<T> ApplyDateRangeOffsetUtc<T>(
            this IQueryable<T> query,
            Expression<Func<T, DateTimeOffset>> utcOffsetSelector,
            DateRange range,
            TimeOnly rollOverUtc)
        {
            if (range == DateRange.None) return query;

            var (start, end) = BusinessDayWindows.GetWindow(range, rollOverUtc);
            return query.Where(BetweenOffsetUtc(utcOffsetSelector, start, end));
        }

        // ---- small helper to rebind selector parameter to our "x" ----
        private static Expression ReplaceParameter(LambdaExpression selector, ParameterExpression newParam)
        {
            var replacer = new ParameterReplacer(selector.Parameters[0], newParam);
            return replacer.Visit(selector.Body)!;
        }

        private sealed class ParameterReplacer : ExpressionVisitor
        {
            private readonly ParameterExpression _from;
            private readonly ParameterExpression _to;

            public ParameterReplacer(ParameterExpression from, ParameterExpression to)
            {
                _from = from; _to = to;
            }

            protected override Expression VisitParameter(ParameterExpression node)
                => node == _from ? _to : base.VisitParameter(node);
        }
    }
}
